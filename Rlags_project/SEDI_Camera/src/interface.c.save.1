/******************************************************************************/
/*                    MAIN ROUTINES FOR GRAPHICAL INTERFACE                   */
/*                                                                            */
/* The routines in this file cover all the interactions between the User and  */
/* the UI (e.g. data entry, button presses etc) and display of data on the    */
/* canvas.                                                                    */
/*                                                                            */
/* Copyright (C) 2009 - 2013  Edward Simonson                                 */
/*                                                                            */
/* This file is part of GoQat.                                                */
/*                                                                            */
/* GoQat is free software; you can redistribute it and/or modify              */
/* it under the terms of the GNU General Public License as published by       */
/* the Free Software Foundation; either version 3 of the License, or          */
/* (at your option) any later version.                                        */
/*                                                                            */
/* This program is distributed in the hope that it will be useful,            */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of             */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              */
/* GNU General Public License for more details.                               */
/*                                                                            */
/* You should have received a copy of the GNU General Public License          */
/* along with this program; if not, see <http://www.gnu.org/licenses/> .      */
/*                                                                            */
/******************************************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <dirent.h>
#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include <glib/gstdio.h>
#include <goocanvas.h>
#ifdef HAVE_LIBGRACE_NP
#include <grace_np.h>
#endif

#define GOQAT_INTERFACE
#include "interface.h"

#ifdef HAVE_SX
#include <libusb-1.0/libusb.h>
#endif

#ifndef HAVE_CONFIG_H
#define PACKAGE "CCD camera interface"
#define VERSION "1.00"
#endif

#ifdef HAVE___AUTOGEN_SH
#undef GOQAT_DATDIR
#define GOQAT_DATADIR "../" 
#undef GLADE_INTERFACE
#define GLADE_INTERFACE "../GoQat-gtkbuilder.glade"
#undef GRACE_TEMPS
#define GRACE_TEMPS "../data/temps.agr"
#undef GRACE_TRACE
#define GRACE_TRACE "../data/trace.agr"
#undef GRACE_HFD
#define GRACE_HFD "../data/hfd.agr"
#undef GOQAT_HFD_PL
#define GOQAT_HFD_PL "../data/Analyse_HFD.pl"
#endif

#define CONFIG_FILE "GoQat.conf"                /* Configuration file name    */
                                                /* Default font for canvas    */
#define FONT "-*-courier-medium-r-normal-*-*-120-*-*-*-*-*"  
#define MAX_LOG_BUF_MSG 100                     /* Max. messages in log buffer*/
 
                                                /* Reading config string      */
#define R_config_d(string1, arg) atoi(ReadCString(string1, "%d", arg))
#define R_config_f(string1, arg) atof(ReadCString(string1, "%f", arg))
#define R_config_s(string1, arg) strcpy(arg, ReadCString(string1, "%s", arg))
                                                /* Writing config string      */
#define W_config_d(string1, arg) WriteCString(string1, g_strdup_printf("%d", arg))
#define W_config_f(string1, arg) WriteCString(string1, g_strdup_printf("%f", arg))
#define W_config_s(string1, arg) WriteCString(string1, g_strdup_printf("%s", arg))

#define set_spin_int(string, arg) set_spin_float(string, (gdouble) arg)

enum AugSettings {TELESCOPE, INSTRUMENT, NSCALIBDURATION, EWCALIBDURATION,
	              GUIDESPEED, MAXSHIFT, MAXDRIFT, MAXMOVE, MAXOFFSET, 
				  DRIFTSAMPLE, CORRFAC, UPDATE, N_COLUMNS};
				                      /* Autoguider settings data fields      */
				  
static GtkBuilder *xml_app = NULL;    /* Main application window              */
static GtkBuilder *xml_img = NULL;    /* Autoguider image window              */
static GtkBuilder *xml_set = NULL;    /* Autoguider settings window           */
static GtkBuilder *xml_agt = NULL;	  /* Autoguider trace window              */
static GtkBuilder *xml_dev = NULL;    /* Device selection window              */
static GtkBuilder *xml_con = NULL;    /* CCD camera configuration window      */
#ifdef HAVE_UNICAP
static GtkBuilder *xml_uni = NULL;    /* Unicap device selection window       */
#endif
static GtkBuilder *xml_fcw = NULL;    /* Focuser configuration window         */
static GtkBuilder *xml_ppd = NULL;    /* Parallel port settings window        */
static GtkBuilder *xml_tsk = NULL;    /* Tasks editing window                 */
static GtkBuilder *xml_lvw = NULL;    /* Live view window                     */
static GtkBuilder *xml_pbw = NULL;    /* Video playback window                */
static GtkBuilder *xml_svf = NULL;    /* Save video file types window         */
static GtkBuilder *xml_pht = NULL;    /* Photometry settings window           */
static GtkBuilder *xml_font = NULL;   /* Font selection dialog                */

static GtkWindow *ccdApp;             /* Window for main application          */
static GtkStatusbar *stsAppStatus;    /* Main application status bar          */
static GtkProgressBar *prgAppBar;     /* Main application progress bar        */
static GtkStatusbar *stsImageStatus;  /* Image window status bar              */
static GHashTable *hshCombo;          /* Hash table for combo box pointers    */
static GKeyFile *KeyFileData;         /* Configuration data                   */
static GtkTreeView *trvSetting;       /* Autog. settings dialog tree view     */
static GtkListStore *lisSetting;      /* List store - autoguider config. data */
static GtkWidget *CCDConfigWin = NULL;/* Currently open CCD config. window    */
static GtkWidget *cnvImage = NULL;    /* Canvas for autoguider images         */
static GtkWidget *cnvHist = NULL;     /* Canvas for autoguider histogram      */
static GooCanvasItem *cgpImage;       /* Autoguider image canvas root group   */
static GooCanvasItem *cgpHist;        /* Autog. histogram canvas root group   */
static GtkWidget *cnvPlayback = NULL; /* Canvas for video playback            */
static GooCanvasItem *cgpPlayback;    /* Video canvas root group              */
static GooCanvasItem *cgpPhotom = NULL; /* Photometric detections group       */
static GtkTextView *txtStatus;        /* CCD camera status window             */
static GtkTextBuffer *txtStatusBuffer;/* Camera status window text buffer     */
static GtkTextView *txtLog;           /* Main log window                      */
static GtkTextBuffer *txtLogBuffer;   /* Main log window text buffer          */
static GtkTextView *txtPhot;          /* Photometry log window                */
static GtkTextBuffer *txtPhotBuffer;  /* Photmetry log window text buffer     */
static GtkTextTag *red;               /* Colour tag for text buffer           */
static GtkTextTag *orange;            /* Colour tag for text buffer           */
static GtkTextTag *blue;              /* Colour tag for text buffer           */
static GtkTextTag *green;             /* Colour tag for text buffer           */
static GtkTextTag *magenta;           /* Colour tag for text buffer           */
static GtkTextTag *magenta_1;         /* Colour tag for text buffer           */
static GtkTextTag *courier;           /* Font tag for text buffer             */

struct cam_img *CCDConfigOwner;       /* Owner of CCD config. window (ccd/aug)*/
static GStaticMutex LogMutex = G_STATIC_MUTEX_INIT; /* Log buffer mutex       */
static pid_t main_tid;                /* Thread id for main (gtk) thread      */
static gint MsgNum = 0;               /* Number of next message in log buffer */
static gchar *LogBuf[MAX_LOG_BUF_MSG];/* Buffer for pending log messages      */
static gchar font[80];                /* Canvas font                          */
const gchar *UserDir;                 /* Path to user's home folder           */
gchar *PrivatePath;                   /* Path to folder for private files     */
gchar *ConfigFile;                    /* Path to configuration file           */
gchar *WatchFile;                     /* Path to 'watch' file                 */
static gchar *tp[NUMTPARAMS];         /* Task parameters (%1, %2 etc)         */
static gboolean CCDAppWinConf = FALSE;/* TRUE if main app. window configured  */
static gboolean AFWinConf = FALSE;    /* TRUE if autofocus conf. window conf'd*/
static gboolean PPWinConf = FALSE;    /* TRUE if parallel port window conf'd  */
static gboolean EdWinConf = FALSE;    /* TRUE if 'Edit Tasks' window config'd */
static gboolean CCDConfigWinConf = FALSE; /* TRUE if 'CCD config.' window conf*/
static gboolean PBWinConf = FALSE;    /* TRUE if playback window configured   */
static gboolean PhotWinConf = FALSE;  /* TRUE if 'Photometry' window config'd */
static gboolean ResetChkState = FALSE;/* TRUE if checkbox state is being reset*/
gboolean GeminiCmds = FALSE;          /* TRUE if Gemini commands to be used   */
gboolean UseUTC = FALSE;              /* TRUE if log files and 'At' use UTC   */
gboolean Debug = FALSE;               /* TRUE if debug messages written to log*/
static FILE *f_log = NULL;            /* Pointer to log file                  */

/******************************************************************************/
/*                                 EVENTS                                     */
/******************************************************************************/

gboolean on_ccdApp_configure (GtkWidget *widget, GdkEventExpose *event,
                              gpointer data);
gboolean on_ccdApp_delete (GtkWidget *widget, GdkEventAny *event,
                           gpointer data);
gboolean on_ccdApp_key_press (GtkWidget *widget, GdkEventKey *event,
                              gpointer data);
gboolean on_txtVBin_focus_out (GtkWidget *widget, GdkEventKey *event,
                               gpointer data);
gboolean on_wndImage_configure (GtkWidget *widget, GdkEventExpose *event,
                                gpointer data);
gboolean on_wndImage_delete (GtkWidget *widget, GdkEventAny *event,
                             gpointer data);
gboolean on_wndImage_key_press (GtkWidget *widget, GdkEventKey *event, 
                                gpointer data);
gboolean on_cnvImage_button_press (GtkWidget *widget, GdkEventButton *event,
                                   gpointer data);
gboolean on_cnvImage_button_release (GtkWidget *widget, GdkEventButton *event,
                                     gpointer data);
gboolean on_cnvImage_motion_notify (GtkWidget *widget, GdkEventMotion *event,
                                    gpointer data);
gboolean on_wndSetting_delete (GtkWidget *widget, GdkEventAny *event,
                               gpointer data);
gboolean on_wndConfigAutofocus_configure (GtkWidget *widget, 
										  GdkEventExpose *event, gpointer data);
gboolean on_wndConfigAutofocus_delete (GtkWidget *widget, GdkEventAny *event,
                                       gpointer data);	
gboolean on_wndParallelPort_configure (GtkWidget *widget, GdkEventExpose *event,
                               	       gpointer data);
gboolean on_wndParallelPort_delete (GtkWidget *widget, GdkEventAny *event,
                                    gpointer data);	
gboolean on_wndEditTasks_configure (GtkWidget *widget, GdkEventExpose *event,
                               	    gpointer data);
gboolean on_wndEditTasks_delete (GtkWidget *widget, GdkEventAny *event,
                                 gpointer data);	
gboolean on_wndQSIConfig_configure (GtkWidget *widget, GdkEventExpose *event,
                                    gpointer data);								 
gboolean on_wndQSIConfig_delete (GtkWidget *widget, GdkEventAny *event,
                                 gpointer data);
gboolean on_wndSXConfig_configure (GtkWidget *widget, GdkEventExpose *event,
                                   gpointer data);
gboolean on_wndSXConfig_delete (GtkWidget *widget, GdkEventAny *event,
                                gpointer data);
gboolean on_trvTasks_button_release (GtkWidget *widget, GdkEventButton *event,
                                     gpointer data);
#ifdef HAVE_UNICAP
gboolean on_wndLiveView_configure (GtkWidget *widget, GdkEventExpose *event,
                               	   gpointer data);
gboolean on_wndLiveView_delete (GtkWidget *widget, GdkEventAny *event,
                                gpointer data);	
#endif
gboolean on_wndPlayback_configure (GtkWidget *widget, GdkEventExpose *event,
                               	   gpointer data);
gboolean on_wndPlayback_delete (GtkWidget *widget, GdkEventAny *event,
                                gpointer data);
gboolean on_cnvPlayback_button_press (GtkWidget *widget, GdkEventButton *event, 
                                      gpointer data);
gboolean on_cnvPlayback_button_release (GtkWidget *widget,GdkEventButton *event, 
                                        gpointer data);
gboolean on_cnvPlayback_motion_notify (GtkWidget *widget, GdkEventMotion *event, 
                                       gpointer data);
gboolean on_wndPhotom_configure (GtkWidget *widget, GdkEventExpose *event,
                               	 gpointer data);
gboolean on_wndPhotom_delete (GtkWidget *widget, GdkEventAny *event,
                              gpointer data);
 
/******************************************************************************/
/*                                 SIGNALS                                    */
/******************************************************************************/

void on_ccdApp_destroy (GtkWidget *widget, gpointer data);
void on_FileSaveCCD_activate (GtkWidget *widget, gpointer data);
void on_FileSaveAUG_activate (GtkWidget *widget, gpointer data);
void on_WriteLog_activate (GtkWidget *widget, gpointer data);
void on_ClearLog_activate (GtkWidget *widget, gpointer data);
void on_CCDConfig_activate (GtkWidget *widget, gpointer data);
void on_Setting_activate (GtkWidget *widget, gpointer data);
void on_FileExit_activate (GtkWidget *widget, gpointer data);
void on_SetCanvasFont_activate (GtkWidget *widget, gpointer data);
void on_WriteDebugToLog_activate (GtkWidget *widget, gpointer data);
void on_Communications_activate (GtkWidget *widget, gpointer data);
void on_TelescopeOpen_activate (GtkWidget *widget, gpointer data);
void on_GeminiCommands_activate (GtkWidget *widget, gpointer data);
void on_CCDCamType_activate (GtkWidget *widget, gpointer data);
void on_CCDSelect_activate (GtkWidget *widget, gpointer data);
void on_CCDOpen_activate (GtkWidget *widget, gpointer data);
void on_FullFrame_activate (GtkWidget *widget, gpointer data);
void on_AutogOpen_activate (GtkWidget *widget, gpointer data);
void on_AutogCamType_activate (GtkWidget *widget, gpointer data);
void on_SXCamSelect_activate (GtkWidget *widget, gpointer data);
void on_Debayer_activate (GtkWidget *widget, gpointer data);
void on_PEC_activate (GtkWidget *widget, gpointer data);
void on_Greyscale_activate (GtkWidget *widget, gpointer data);
void on_ParallelPort_activate (GtkWidget *widget, gpointer data);
void on_ParPortOpen_activate (GtkWidget *widget, gpointer data);
void on_FocusOpen_activate (GtkWidget *widget, gpointer data);
void on_PrecessCoords_activate (GtkWidget *widget, gpointer data);
void on_UseUTC_activate (GtkWidget *widget, gpointer data);
void on_Playback_activate (GtkWidget *widget, gpointer data);
void on_CCDTemps_activate (GtkWidget *widget, gpointer data);
void on_AutogTrace_activate (GtkWidget *widget, gpointer data);
void on_ShowToolbar_activate (GtkWidget *widget, gpointer data);
void on_HelpAbout_activate (GtkWidget *widget, gpointer data);
void on_btnFullFrame_clicked (GtkButton *button, gpointer data);
void on_btnGetRegion_clicked (GtkButton *button, gpointer data);
void on_spbBin_value_changed (GtkSpinButton *spin, gpointer data);
void on_txtExposure_activate (GtkEditable *editable, gpointer data);
void on_cmbExpType_changed (GtkWidget *widget, gpointer data);
void on_chkBeepExposure_toggled (GtkButton *button, gpointer data);
void on_btnStart_clicked (GtkButton *button, gpointer data);
void on_btnCancel_clicked (GtkButton *button, gpointer data);
void on_btnInterrupt_clicked (GtkButton *button, gpointer data);
void on_chkAutoSave_toggled (GtkButton *button, gpointer data);
void on_chkSaveEvery_toggled (GtkButton *button, gpointer data);
void on_chkWatchActive_toggled (GtkButton *button, gpointer data);
void on_btnPPClose_clicked (GtkButton *button, gpointer data);
void on_btnZoomIn_clicked (GtkButton *button, gpointer data);
void on_btnZoomOut_clicked (GtkButton *button, gpointer data);
void on_btnZoom1to1_clicked (GtkButton *button, gpointer data);
void on_btnResetArea_clicked (GtkButton *button, gpointer data);
void on_txtImgSatLevel_activate (GtkEntry *entry, gpointer data);
void on_txtImgExpLength_activate (GtkEntry *entry, gpointer data);
void on_optImgBin_toggled (GtkButton *button, gpointer data);
void on_hscBackground_changed (GtkRange *range, gpointer data);
void on_hscBrightness_changed (GtkRange *range, gpointer data);
void on_hscContrast_changed (GtkRange *range, gpointer data);
void on_hscGamma_changed (GtkRange *range, gpointer data);
void on_hscGain_changed (GtkRange *range, gpointer data);
void on_btnFntSel_clicked (GtkButton *button, gpointer data);
void on_chkAutogOpen_toggled (GtkButton *button, gpointer data);
void on_chkAutogWrite_toggled (GtkButton *button, gpointer data);
void on_spbAutogGuideSpeed_changed (GtkSpinButton *spin, gpointer data);
void on_btnAutogDS9_clicked (GtkButton *button, gpointer data);
void on_btnAutogCapDark_clicked (GtkButton *button, gpointer data);
void on_chkAutogSubDark_toggled (GtkButton *button, gpointer data);
void on_txtAutogSkySigma_activate (GtkEntry *entry, gpointer data);
void on_txtAutogCentroidSize_activate (GtkEntry *entry, gpointer data);
void on_chkAutogShowCentroid_toggled (GtkButton *button, gpointer data);
void on_tglAutogStart_toggled (GtkButton *button, gpointer data);
void on_tglAutogPause_toggled (GtkButton *button, gpointer data);
void on_btnAutog_pressed (GtkButton *button, gpointer data);
void on_btnAutog_released (GtkButton *button, gpointer data);
void on_btnAutogCalibrate_clicked (GtkButton *button, gpointer data);
void on_btnSaveSetting_clicked (GtkButton *button, gpointer data);
void on_btnLoadSetting_clicked (GtkButton *button, gpointer data);
void on_btnDeleteSetting_clicked (GtkButton *button, gpointer data);
void on_btnCloseSetting_clicked (GtkButton *button, gpointer data);
void on_btnFocusIn_clicked (GtkButton *button, gpointer data);
void on_btnFocusOut_clicked (GtkButton *button, gpointer data);
void on_btnFocusMoveTo_clicked (GtkButton *button, gpointer data);
void on_btnFocusStop_clicked (GtkButton *button, gpointer data);
void on_btnFocusConfig_clicked (GtkButton *button, gpointer data);
void on_btnFocusFocus_clicked (GtkButton *button, gpointer data);
void on_btnFocusAFStop_clicked (GtkButton *button, gpointer data);
void on_btnFocusMaxTravelSet_clicked (GtkButton *button, gpointer data);
void on_btnFocusCurrentPosSet_clicked (GtkButton *button, gpointer data);
void on_btnFocusBacklashSet_clicked (GtkButton *button, gpointer data);
void on_btnFocusMotorConfigSet_clicked (GtkButton *button, gpointer data);
void on_btnFocusGetCurrentSettings_clicked (GtkButton *button, gpointer data);
void on_chkFocusApplyFilterOffsets_toggled (GtkButton *button, gpointer data);
void on_chkFocusTempComp_toggled (GtkButton *button, gpointer data);
void on_chkFocusFastReadout_toggled (GtkButton *button, gpointer data);
void on_btnAFConfigMeasureHFD_clicked (GtkButton *button, gpointer data);
void on_btnAFConfigClearData_clicked (GtkButton *button, gpointer data);
void on_btnAFConfigStopHFD_clicked (GtkButton *button, gpointer data);
void on_btnAFConfigCalculate_clicked (GtkButton *button, gpointer data);
void on_btnAFConfigUseResults_clicked (GtkButton *button, gpointer data);
void on_btnGemModelLoad_clicked (GtkButton *button, gpointer data);
void on_btnGemModelSave_clicked (GtkButton *button, gpointer data);
void on_btnGemModelRead_clicked (GtkButton *button, gpointer data);
void on_btnGemModelWrite_clicked (GtkButton *button, gpointer data);
void on_btnGemPECLoad_clicked (GtkButton *button, gpointer data);
void on_btnGemPECSave_clicked (GtkButton *button, gpointer data);
void on_btnGemDefaultsLoad_clicked (GtkButton *button, gpointer data);
void on_btnGemSetTime_clicked (GtkButton *button, gpointer data);
void on_btnGemStatus_clicked (GtkButton *button, gpointer data);
void on_btnTaskEdit_clicked (GtkButton *button, gpointer data);
void on_btnTaskUp_clicked (GtkButton *button, gpointer data);
void on_btnTaskDown_clicked (GtkButton *button, gpointer data);
void on_btnTaskDelete_clicked (GtkButton *button, gpointer data);
void on_btnTaskClear_clicked (GtkButton *button, gpointer data);
void on_btnTaskStart_clicked (GtkButton *button, gpointer data);
void on_btnTaskPause_clicked (GtkButton *button, gpointer data);
void on_btnTaskStop_clicked (GtkButton *button, gpointer data);
void on_btnTObject_clicked (GtkButton *button, gpointer data);
void on_btnTBeginSequence_clicked (GtkButton *button, gpointer data);
void on_btnTWaitUntil_clicked (GtkButton *button, gpointer data);
void on_btnTPauseFor_clicked (GtkButton *button, gpointer data);
void on_btnTAt_clicked (GtkButton *button, gpointer data);
void on_btnTExpose_clicked (GtkButton *button, gpointer data);
void on_cmbTExpType_changed (GtkWidget *widget, gpointer data);
void on_btnTBeginLoop_clicked (GtkButton *button, gpointer data);
void on_btnTEndLoop_clicked (GtkButton *button, gpointer data);
void on_btnTFocusTo_clicked (GtkButton *button, gpointer data);
void on_btnTFocusMove_clicked (GtkButton *button, gpointer data);
void on_btnTIfTrue_clicked (GtkButton *button, gpointer data);
void on_btnTIfFalse_clicked (GtkButton *button, gpointer data);
void on_btnTEndIf_clicked (GtkButton *button, gpointer data);
void on_btnTWhile_clicked (GtkButton *button, gpointer data);
void on_btnTEndWhile_clicked (GtkButton *button, gpointer data);
void on_btnTAugOn_clicked (GtkButton *button, gpointer data);
void on_btnTAugOff_clicked (GtkButton *button, gpointer data);
void on_btnTGuideStart_clicked (GtkButton *button, gpointer data);
void on_btnTGuideStop_clicked (GtkButton *button, gpointer data);
void on_btnTGoTo_clicked (GtkButton *button, gpointer data);
void on_btnTMove_clicked (GtkButton *button, gpointer data);
void on_btnTExec_clicked (GtkButton *button, gpointer data);
void on_btnTExecAsync_clicked (GtkButton *button, gpointer data);
void on_btnTWarmRestart_clicked (GtkButton *button, gpointer data);
void on_btnTParkMount_clicked (GtkButton *button, gpointer data);
void on_btnTRecordStart_clicked (GtkButton *button, gpointer data);
void on_btnTRecordStop_clicked (GtkButton *button, gpointer data);
void on_btnTYellow_clicked (GtkButton *button, gpointer data);
void on_btnTShutdown_clicked (GtkButton *button, gpointer data);
void on_btnTExit_clicked (GtkButton *button, gpointer data);
void on_btnTLoadTasks_clicked (GtkButton *button, gpointer data);
void on_btnTSaveTasks_clicked (GtkButton *button, gpointer data);
void on_btnTCloseWindow_clicked (GtkButton *button, gpointer data);
void on_btnLVClose_clicked (GtkButton *button, gpointer data);
void on_btnPBZoomIn_clicked (GtkButton *button, gpointer data);
void on_btnPBZoomOut_clicked (GtkButton *button, gpointer data);
void on_btnPBZoom1to1_clicked (GtkButton *button, gpointer data);
void on_btnPBResetArea_clicked (GtkButton *button, gpointer data);
void on_btnPBOpenFile_clicked (GtkButton *button, gpointer data);
void on_txtPBFrameNum_activate (GtkEditable *editable, gpointer data);
void on_txtPBTimeStamp_activate (GtkEditable *editable, gpointer data);
void on_btnPBSetTimes_clicked (GtkButton *button, gpointer data);
void on_hscPBFrames_changed (GtkRange *range, gpointer data);
void on_btnPBPlay_clicked (GtkButton *button, gpointer data);
void on_btnPBStop_clicked (GtkButton *button, gpointer data);
void on_btnPBPrev_clicked (GtkButton *button, gpointer data);
void on_btnPBNext_clicked (GtkButton *button, gpointer data);
void on_btnPBMarkFirst_clicked (GtkButton *button, gpointer data);
void on_btnPBMarkLast_clicked (GtkButton *button, gpointer data);
void on_cmbPBfps_changed (GtkComboBox *combo, gpointer data);
void on_btnPBSaveFrames_clicked (GtkButton *button, gpointer data);
void on_btnPBPhotom_clicked (GtkButton *button, gpointer data);
void on_btnPBClose_clicked (GtkButton *button, gpointer data);
void on_btnPhotSingle_clicked (GtkButton *button, gpointer data);
void on_btnPhotRange_clicked (GtkButton *button, gpointer data);
void on_btnPhotClearLog_clicked (GtkButton *button, gpointer data);
void on_btnPBClose_clicked (GtkButton *button, gpointer data);
void on_btnSVOK_clicked (GtkButton *button, gpointer data);
void on_btnDevSelect_clicked (GtkButton *button, gpointer data);
void on_btnUnicapSelect_clicked (GtkButton *button, gpointer data);
void on_chkCConfHasCooling_toggled (GtkButton *button, gpointer data);
void on_chkCConfCoolOnConnect_toggled (GtkButton *button, gpointer data);
void on_btnCConfSetDefTemp_clicked (GtkButton *button, gpointer data);
void on_btnCConfCoolerOn_clicked (GtkButton *button, gpointer data);
void on_btnCConfCoolerOff_clicked (GtkButton *button, gpointer data);
void on_optCConfFans_toggled (GtkButton *button, gpointer data);
void on_btnCConfSetFans_clicked (GtkButton *button, gpointer data);
void on_cmbCConfShutPrior_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfShutMode_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfShutOpen_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfPreFlush_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfFastMode_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfCameraGain_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfReadoutSpeed_changed (GtkComboBox *combo, gpointer data);
void on_cmbCConfAntiBlooming_changed (GtkComboBox *combo, gpointer data);
void on_btn_CConfSetShutPrior_clicked (GtkButton *button, gpointer data);
void on_btn_CConfSetShutMode_clicked (GtkButton *button, gpointer data);
void on_btn_CConfSetShutOpen_clicked (GtkButton *button, gpointer data);
void on_btn_CConfSetPreFlush_clicked (GtkButton *button, gpointer data);
void on_btn_CConfSetFastMode_clicked (GtkButton *button, gpointer data);
void on_btn_CConfSetCamGain_clicked (GtkButton *button, gpointer data);
void on_btnCConfSetReadoutSpeed_clicked (GtkButton *button, gpointer data);
void on_btn_CConfSetAntiBloom_clicked (GtkButton *button, gpointer data);
void on_cmbCConfWheel_changed (GtkComboBox *combo, gpointer data);
void on_btnCConfSaveFilterSettings_clicked (GtkButton *button, gpointer data);
void on_btnCConfRotate_clicked (GtkButton *button, gpointer data);
void on_chkCConfInvertImage_toggled (GtkButton *button, gpointer data);
void on_chkCConfDebayer_toggled (GtkButton *button, gpointer data);
void on_cmbCConfBayerPattern_changed (GtkComboBox *combo, gpointer data);
void on_btnCConfClose_clicked (GtkButton *button, gpointer data);
gboolean IsCConfCombo (gpointer key, gpointer value, gpointer data);
void on_LiveView_activate (GtkWidget *widget, gpointer data);
void on_UnicapDevice_activate (GtkWidget *widget, gpointer data);
void on_UnicapProperties_activate (GtkWidget *widget, gpointer data);
#ifdef HAVE_UNICAP
void on_tglLVRecord_toggled (GtkButton *button, gpointer data);
#endif  /* UNICAP */


/******************************************************************************/
/*                           MISCELLANEOUS FUNCTIONS                          */
/******************************************************************************/

gboolean get_entry_int (const gchar *name, gint minval, gint maxval,
                        gint defval, gint page, gint *val);
gboolean get_entry_float (const gchar *name,
                          gdouble minval, gdouble maxval, 
                          gdouble defval, gint page, gdouble *val);
gchar *get_entry_string (const gchar *name);
static void get_spin_int (const gchar *name, gint *val);
static void get_spin_float (const gchar *name, gdouble *val);
static void set_entry_int (const gchar *name, gint val);
void set_entry_float (const gchar *name, gdouble val);
void set_entry_string (const gchar *name, gchar *string);
static void set_spin_float (const gchar *name, gdouble val);
static GtkEntry *get_entry_widget (const gchar *name);
static GtkSpinButton *get_spin_widget (const gchar *name);
void set_ccd_gui (gboolean set);
void set_exposure_buttons (gboolean active);
void set_task_buttons (gboolean active);
void set_focus_done (void);
void set_progress_bar (gboolean zeroise, gint elapsed);
void set_status_bar (GtkStatusbar *bar, gchar *message, gboolean Clear);
void set_range_minmaxstep (enum Range range, gdouble min, gdouble max, 
						   gdouble step, gushort dp);
void set_range_value (enum Range range, gboolean Sensitive, gdouble value);
static void set_notebook_page (gint page);
void set_elapsed_time (guint elapsed);
void set_fits_data (struct cam_img *img, struct timeval *time, 
	                gboolean UseDateobs, gboolean QueryHardware);
	
void set_autog_on (gboolean on);
void set_guide_on (gboolean on);
void get_autog_guide_params (void);
void get_autog_movespeed (gboolean *CenterSpeed, gfloat *speed);
void set_autog_sensitive (gboolean sensitive, gboolean autogopened);
void set_autog_calibrate_done (void);

static void canvas_button_press (GtkWidget *widget, GdkEventButton *event,
                                 struct cam_img *img);
static void canvas_button_release (struct cam_img *img);
static void canvas_motion_notify (GdkEventMotion *event, struct cam_img *img);
static void canvas_zoom_image (GtkWidget *canv, struct cam_img *img, 
                               enum ZoomType zoom);
gboolean ui_show_augcanv_image (void);
void ui_show_augcanv_rect (gboolean Show);
void ui_set_augcanv_rect_colour (gchar *colour);
void ui_set_augcanv_rect_full_area (void);
void ui_set_augcanv_crosshair (gdouble x, gdouble y);
GooCanvasItem *ui_show_augcanv_plot (GooCanvasPoints *points,
                                     GooCanvasItem *plot);
static void ui_show_augcanv_plot_titles (void);
GooCanvasItem *ui_show_augcanv_text (gdouble x, gdouble y, gchar *string, 
                                     gdouble val, gushort type, gint sigfig, 
                                     gchar *colour, GooCanvasItem *text);
void ui_show_augcanv_centroid (gboolean show, gboolean saturated, 
                               gfloat h, gfloat v,
                               gushort x1, gushort x2, gushort y1, gushort y2);
void ui_set_aug_window_controls (enum CamDevice dev, gboolean Binning);
                               
void ui_show_video_frame (guchar *frame, gchar *timestamp, guint num, 
					      gushort h, gushort v);
void ui_show_photom_points (gchar *filename, gfloat aperture);
void set_video_range_adjustment (guint num_frames);
void set_video_range_value (guint frame_num);
gushort get_video_framebufsize (void);

static gchar *get_open_filename (GtkWindow *window, gchar *filename);
static gchar *get_save_filename (GtkWindow *window, gchar *filename);
gboolean save_file (struct cam_img *img, enum Colour colour, gboolean display);
void file_saved (struct cam_img *img, gboolean saved);
static gboolean query_file_not_saved (void);
static gboolean check_file (gchar *filename, gboolean Overwrite);

void ui_show_aug_window (void);
void ui_hide_aug_window (void);

void select_device (struct cam_img *img, gint num);
void get_ccd_image_params (struct exposure_data *exd);
void set_camera_state (struct cam_img *img);
gboolean set_filter (enum CamType type, gchar *filter, gint *fo_diff);
gboolean get_apply_filter_offset (void);
void apply_filter_focus_offset (enum CamType type, gint offset);
void set_ccd_deftemp (void);
gboolean show_camera_status (gboolean show);
gchar *get_filter_info (struct cam_img *img, gint pos, gchar *filter,
	                    gint *offset);
void check_focuser_temp (void);

static void ui_show_status_bar_info (void);
static void select_entry_region (const gchar *name);
static void common_keyboard_shortcuts (GdkEventKey *event);
static void comms_menus_update_ports (void);
static void comms_ports_set_active (GtkWidget *widget, gpointer data);
static void comms_ports_activate_cb (GtkWidget* widget, gpointer data);
static void comms_ports_set_sensitive (GtkWidget *widget, gpointer data);
static void comms_menus_remove_ports (GtkWidget *widget, gpointer data);
static void restore_config_data (void);
static void save_config_data (void);
static void restore_watch_file (void);
void save_PEC_guide_speed (gfloat GuideSpeed);
void save_RA_worm_pos (gushort WormPos);
gfloat get_goto_motion_limit (void);
void reset_checkbox_state (enum CheckBox chkbox, gboolean active);
gboolean check_format (gboolean is_RA, gchar s[]);
struct tm *get_time (gboolean UTC);
gint get_UTC_offset (void);
void finished_tasks (void);

static void warn_PEC_guidespeed (gboolean MsgBox);
void msg (const gchar *message);
void err_msg (gchar *entry_text, const gchar *message);
gboolean show_error (const gchar *routine, const gchar *message);
static void InitApp (void);
void WriteLog (char *string);
void FlushLog (void);
void WritePhot (char *string);
static gchar *ReadCString (gchar *string, gchar *fmt, ...);
static gchar **ReadCArray (gchar *string);
static void WriteCString (gchar *string, gchar *val);
static void DeleteCGroup (gchar *string);
static gchar *CCDConfigKey (struct cam_img *img, const gchar *str);
	
void init_task_params (void);
void free_task_params (void);
void get_task_params (gchar **tparams);
void set_task_params (gchar **tparams);
gchar *get_task_param_value (gboolean FreeString, gchar *string, gint *status);

void exit_and_shutdown (void);

#ifdef HAVE_UNICAP
static void unicap_device_change_cb (UnicapgtkDeviceSelection *selection,
									 gchar *device_id, GtkWidget *format);
static void unicap_format_change_cb (GtkWidget *ugtk, unicap_format_t *format,
                                     gpointer *p);
void set_record_on (gboolean on);
gboolean liveview_record_is_writeable (void);
gboolean open_liveview_window (void);
void show_liveview_window (void);
void hide_liveview_window (void);
void close_liveview_window (void);
#endif

static GtkBuilder *xml_load_new(GtkBuilder *xml, gchar *file, gchar *objects[]);
GtkWidget *xml_get_widget (GtkBuilder *xml, const gchar *name);
static GtkComboBox *create_text_combo_box (GtkTable *tblTable, guint l, guint r,
                                           guint t, guint b, 
                                           GtkComboBox *cmbBox, 
                                           const gchar *list, guint index,
                                           GCallback func);


/******************************************************************************/
/*                                 EVENTS                                     */
/******************************************************************************/

gboolean on_ccdApp_configure (GtkWidget *widget, GdkEventExpose *event,
                              gpointer data)
{
	/* Set up some initial values when the application is loaded */
	
	static GtkComboBox *cmbExpType, *cmbFilType;
	gushort j;
	
	if (!CCDAppWinConf) {
	
        /* Create and fill exposure type and filter combo boxes */
        
        cmbExpType = create_text_combo_box (
                              GTK_TABLE (xml_get_widget (xml_app, "tblCCD")),
                              1, 2, 5, 6, cmbExpType, "ListCCDExposureTypes", 
                              0, (GCallback) on_cmbExpType_changed);
        g_hash_table_insert (hshCombo, "cmbExpType", cmbExpType);
        cmbFilType = create_text_combo_box (
                              GTK_TABLE (xml_get_widget (xml_app, "tblCCD")),
                              3, 4, 5, 6, cmbFilType, "ListCCDFilterTypes", 
                              0, NULL);
        g_hash_table_insert (hshCombo, "cmbFilType", cmbFilType);
		
		/* Initialise task parameters */
		
		for (j = 0; j < NUMTPARAMS; j++)
			tp[j] = NULL;
		
		CCDAppWinConf = TRUE;
	}
	
	return FALSE;
}
							  
gboolean on_ccdApp_delete (GtkWidget *widget, GdkEventAny *event, gpointer data)
{
	/* Tidy up */
	
	/* Ask the user whether to save any unsaved file before exiting */
	
	if (!query_file_not_saved ()) {
		loop_stop_loop ();
		CCDAppWinConf = FALSE;
	}
	
	/* Don't let the main window be destroyed at this point, otherwise the event
	 * loop might still try to write to it even though it's not there.
	 */
	
	return TRUE;
}

gboolean on_ccdApp_key_press (GtkWidget *widget, GdkEventKey *event,
                              gpointer data)
{
	struct cam_img *aug = get_aug_image_struct ();
		
	/* Implement keyboard shortcuts */
	
	common_keyboard_shortcuts (event);
	
	/* Shortcuts pertaining to the main window only */
	
	switch (event->keyval) {
		
		case GDK_Escape:  /* Switch to image window */
			if (gtk_widget_get_visible (aug->aug_window))
				gtk_window_present (GTK_WINDOW (aug->aug_window));
			break;
	}		
	
	return FALSE;
}

gboolean on_txtVBin_focus_out (GtkWidget *widget, GdkEventKey *event,
                               gpointer data)
{
	/* Warn the user if the entered value is invalid and modify it */
	
	struct cam_img *ccd = get_ccd_image_struct ();
	
	gint val_h, val_v;
	
	get_entry_int ("txtHBin", 0, ccd->cam_cap.max_binh, 1, NO_PAGE, &val_h);
	get_entry_int ("txtVBin", 0, ccd->cam_cap.max_binv, 1, NO_PAGE, &val_v);
	if (ccd->device == SX && ccd->cam_cap.IsInterlaced && val_v > 1 && val_v%2)
		L_print ("{o}Vertical binning value restricted to even numbers "
				 "for interlaced camera: using %dx%d\n",
				  val_h, --val_v);
	set_entry_int ("txtVBin", val_v);
	
	return FALSE;
}
	
gboolean on_wndImage_configure (GtkWidget *widget, GdkEventExpose *event,
                                gpointer data)
{
	/* Create and initialise the autoguider canvases */
	
	struct cam_img *aug = get_aug_image_struct ();
	
	GdkCursor *cursor;
	gushort i;
	gint level;
	
	if (cnvImage)
		return FALSE;

	/* Image canvas... */
	
	cnvImage = goo_canvas_new ();
	gtk_widget_set_size_request (cnvImage, AUGCANV_H, AUGCANV_V);
	goo_canvas_set_bounds (GOO_CANVAS (cnvImage), 0, 0, AUGCANV_H, AUGCANV_V);
    g_object_set (G_OBJECT (cnvImage), "background-color", "black", NULL);
    gtk_widget_set_events (cnvImage, GDK_MOTION_NOTIFY | 
                                     GDK_BUTTON_PRESS  | 
                                     GDK_BUTTON_RELEASE);
    g_signal_connect (cnvImage, "motion-notify-event", 
                      (GCallback) on_cnvImage_motion_notify,
                      NULL);
    g_signal_connect (cnvImage, "button-press-event", 
                      (GCallback) on_cnvImage_button_press,
                      NULL);
    g_signal_connect (cnvImage, "button-release-event", 
                      (GCallback) on_cnvImage_button_release,
                      NULL);

	gtk_widget_show (cnvImage);
	gtk_container_add (GTK_CONTAINER (xml_get_widget (
	                                           xml_img, "scwImage")), cnvImage);
	cgpImage = goo_canvas_get_root_item (GOO_CANVAS (cnvImage));
    
	/* Draw the selection rectangle */
		
	aug->canv.cviRect = goo_canvas_rect_new (cgpImage,
						                     0.0,
						                     0.0,
						                     (gdouble) (AUGCANV_H - 1),
						                     (gdouble) (AUGCANV_V - 1),
						                     "stroke-color", "green",
                                             "line-width", 2.0,
						                     NULL);

	aug->canv.NewRect = TRUE;
	
	/* Initialise the crosshair */
	
	aug->canv.chx_line = NULL;
	aug->canv.chy_line = NULL;		
	ui_set_augcanv_crosshair (AUGCANV_H / 2.0, AUGCANV_V / 2.0);
	
	/* Set cursor for canvas */
						  
	cursor = gdk_cursor_new (GDK_CROSSHAIR);		
	gdk_window_set_cursor (gtk_widget_get_window (cnvImage), cursor);
    
    /* Set initial zoom factor */
    
    aug->canv.zoom = 1.0;
    
	/* Histogram canvas... */
		
	cnvHist = goo_canvas_new ();
	gtk_widget_set_size_request (cnvHist, HWID, -1);
	goo_canvas_set_bounds (GOO_CANVAS (cnvHist), 0, 0, HWID, AUGCANV_V + 20);
    g_object_set (G_OBJECT (cnvHist), "background-color", "black", NULL);
	gtk_widget_show (cnvHist);
	gtk_box_pack_end (GTK_BOX (xml_get_widget (
	                   xml_img, "hbxImageCanvases")), cnvHist, FALSE, FALSE, 2);
	cgpHist = goo_canvas_get_root_item (GOO_CANVAS (cnvHist));	
		
	/* Draw the histogram and x/y flux plot windows */
		
	for (i = YHIST; i < 600 - BOXSIZE; i+= YGAP + BOXSIZE)
		goo_canvas_rect_new (cgpHist,
							 (gdouble) (XPLOT - 1),
							 (gdouble) (i - 1),
							 (gdouble) (BOXSIZE + 1),
							 (gdouble) (BOXSIZE + 1),
							 "stroke-color", "green",
		    				 "line-width", 1.5,
							 NULL);
	
	/* Label the plots */
		
	strcpy (font, FONT);  /* Set the default value for font */
	R_config_s ("Canvas/Font", font);
	ui_show_augcanv_plot_titles ();
	
	/* Get the initial values of the exposure length and saturation level */
	
	get_entry_float("txtImgExpLength", 0.001, 99.9,1,NO_PAGE,&aug->exd.req_len);
	get_entry_int ("txtImgSatLevel", aug->imdisp.B, aug->imdisp.W,
					                            aug->imdisp.W, NO_PAGE, &level);
    aug->imdisp.satlevel = (gushort) level;
		
	/* Finally, display status bar info... */
		
	ui_show_status_bar_info ();
	
	return FALSE;
}	

gboolean on_wndImage_delete (GtkWidget *widget, GdkEventAny *event,
                             gpointer data)
{
	/* Don't ever want the user to close this window via the window menu, so 
	 * always return TRUE.
 	 */

	if (!gtk_toggle_button_get_active (
		 GTK_TOGGLE_BUTTON (xml_get_widget (xml_app, "tglAutogStart"))) &&
		!gtk_toggle_button_get_active (
		 GTK_TOGGLE_BUTTON (xml_get_widget (xml_app, "tglAutogPause"))))
		gtk_widget_activate (xml_get_widget (xml_app, "chkAutogOpen"));
	return TRUE;
}

gboolean on_wndImage_key_press (GtkWidget *widget, GdkEventKey *event,
                                gpointer data)
{
	/* Implement keyboard shortcuts */
	
	/* Common keyboard shortcuts */
	
	common_keyboard_shortcuts (event);

	/* Shortcuts pertaining to the image window only */
	
	switch (event->keyval) {
		
		case GDK_Escape:  /* Switch to main window */
			gtk_window_present (ccdApp);
			break;
	}
			
	return FALSE;	
}

gboolean on_cnvImage_button_press (GtkWidget *widget, GdkEventButton *event,
                                   gpointer data)
{
	/* Perform mouse operations */

	struct cam_img *aug = get_aug_image_struct ();
	
	/* Return if guiding */
	
	if (aug->autog.Guide)
		return TRUE;
    
    /* Left mouse button down... */
    
    if (event->button == 1)
        canvas_button_press (widget, event, aug);
		
    return TRUE;
}

gboolean on_cnvImage_button_release (GtkWidget *widget, GdkEventButton *event,
                                     gpointer data)
{
	/* When the left mouse button is released, ungrab the pointer */
	
	struct cam_img *aug = get_aug_image_struct ();
	
	/* Return if guiding */

	if (aug->autog.Guide)
		return TRUE;
	
    /* Left mouse button up... */
        
    if (event->button == 1)
        canvas_button_release (aug);
	
    return TRUE;
}

gboolean on_cnvImage_motion_notify (GtkWidget *widget, GdkEventMotion *event,
                                    gpointer data)
{
	/* Grab the cursor coordinates.  Draw the selection rectangle when the mouse
     * is moved with the left button pressed, and move it if the shift button is
     * held down.
     */

	struct cam_img *aug = get_aug_image_struct ();
		
    /* Return if guiding */
	
	if (aug->autog.Guide)
		goto write_info;
        
	aug->canv.cursor_x = (gint) (event->x / aug->canv.zoom);
    aug->canv.cursor_y = (gint) (event->y / aug->canv.zoom);
	
    /* Draw/move rectangle */
    
    canvas_motion_notify (event, aug);
		
	/* Write pointer location and other info to status bar */
	
write_info:
	ui_show_status_bar_info ();
		
    return TRUE;
}

gboolean on_wndSetting_delete (GtkWidget *widget, GdkEventAny *event,
                               gpointer data)
{
	/* Don't ever want the user to close this window via the window menu, so 
	 * always return TRUE.
 	 */
	
	gtk_widget_activate (xml_get_widget (xml_set, "btnCloseSetting"));
	return TRUE;
}

gboolean on_wndConfigAutofocus_configure (GtkWidget *widget, 
										  GdkEventExpose *event, gpointer data)
{
	/* Configure the autofocus configuration window */
	
	if (!AFWinConf) {
		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (xml_get_widget (
						              xml_fcw, "optAFConfigSetRange")), TRUE);
		AFWinConf = TRUE;
	}
	
	return FALSE;
}

gboolean on_wndConfigAutofocus_delete (GtkWidget *widget, GdkEventAny *event,
                                       gpointer data)
{
	/* Close focus configuration window and tidy up */
	
	loop_ccd_calibrate_autofocus (FALSE, 0, 0, 0, 0, 0.0, 0); /* Stop calib. */
	
	gtk_widget_destroy (xml_get_widget (xml_fcw, "wndConfigAutofocus"));
	g_object_unref (G_OBJECT (xml_fcw));
	xml_fcw = NULL;
	AFWinConf = FALSE;
	return FALSE;
}

gboolean on_wndParallelPort_configure (GtkWidget *widget, GdkEventExpose *event,
                               	       gpointer data)
{
	/* Configure the parallel port settings window */
	
	if (!PPWinConf) {
		set_entry_string ("txtPPAddress", ports[LPT].address);
		set_entry_int ("txtPPRAp", ports[LPT].RAp);
		set_entry_int ("txtPPRAm", ports[LPT].RAm);
		set_entry_int ("txtPPDecp", ports[LPT].Decp);
		set_entry_int ("txtPPDecm", ports[LPT].Decm);
		//set_entry_int ("txtPPSC1LongExp", ports[LPT].SC1LongExp);
		//set_entry_int ("txtPPSC1Pause", ports[LPT].SC1Pause);
		PPWinConf = TRUE;
	}
	
	return FALSE;
}

gboolean on_wndParallelPort_delete (GtkWidget *widget, GdkEventAny *event,
                                    gpointer data)
{
	/* Don't ever want the user to close this window via the window menu, so 
	 * always return TRUE.
 	 */
	
	gtk_widget_activate (xml_get_widget (xml_ppd, "btnPPClose"));
	return TRUE;	
}

gboolean on_wndEditTasks_configure (GtkWidget *widget, GdkEventExpose *event,
                               	    gpointer data)
{
	/* Configure the tasks editing window */
	
	struct cam_img *ccd = get_ccd_image_struct ();
	
	static GtkComboBox *cmbTExpType, *cmbTFilType;
	
	if (!EdWinConf) {
		
